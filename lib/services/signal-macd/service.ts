// lib/services/signal-macd/service.ts
import { SupabaseClient } from "@supabase/supabase-js";
import { getSupabaseServerClient } from "@/lib/supabase/serverClient";
import type { Database } from "@/lib/supabase/database.types";

// --- Types specific to this service ---
type HistoricalPrice = Database["public"]["Tables"]["historical_prices"]["Row"];
type PriceDataPoint = Pick<HistoricalPrice, "date" | "close">;

export type MacdSignalInsert = Omit<
  Database["public"]["Tables"]["signals"]["Insert"],
  "signal_category" | "signal_type"
> & {
  signal_category: "technical";
  signal_type: "event"; // MACD crosses are events
};

export interface MacdProcessingResult {
  processedSymbol: string;
  signalsGenerated: number;
  status: string; // e.g., "processed", "skipped_fresh", "no_data", "error"
  error?: string;
  latestSignalDate?: string | null; // To indicate the date of data used for the signal
}

// --- Configuration & Constants ---
const SIGNALS_TABLE_NAME = "signals";
const HISTORICAL_PRICES_TABLE_NAME = "historical_prices";

const MACD_FAST_PERIOD = 12;
const MACD_SLOW_PERIOD = 26;
const MACD_SIGNAL_PERIOD = 9;
// Fetch extra for EMA stability and to ensure enough points for all calculations
const REQUIRED_DATA_POINTS_MACD = MACD_SLOW_PERIOD + MACD_SIGNAL_PERIOD + 50;

// Signal codes generated by this service
const MACD_SIGNAL_CODES: string[] = [
  "MACD_CROSS_ABOVE",
  "MACD_CROSS_BELOW",
  "MACD_ZERO_CROSS_ABOVE",
  "MACD_ZERO_CROSS_BELOW",
];

// Time-to-live for these signals: 23 hours (to refresh daily)
export const MACD_SIGNALS_TTL_MS = 23 * 60 * 60 * 1000;

// --- MACD Calculation Helpers (from original route) ---
// Assumes values are ordered chronologically (oldest first)
function calculateEMAValues(values: number[], period: number): number[] {
  if (!values || values.length < period || period <= 0) return [];
  const k = 2 / (period + 1);
  const emaArray: number[] = new Array(values.length).fill(NaN); // Initialize with NaN

  // Initial SMA
  let sum = 0;
  for (let i = 0; i < period; i++) {
    sum += values[i];
  }
  emaArray[period - 1] = sum / period;

  // Subsequent EMAs
  for (let i = period; i < values.length; i++) {
    const previousEma = emaArray[i - 1];
    if (isNaN(previousEma)) {
      // Should not happen if logic is correct
      console.warn("[MACD Service] Previous EMA is NaN during calculation.");
      break;
    }
    emaArray[i] = values[i] * k + previousEma * (1 - k);
  }
  // Return only the valid EMA part, corresponding to original values' indices
  return emaArray;
}

// Assumes prices are sorted DESC (latest first)
function calculateMACDAndSignalLine(
  prices: PriceDataPoint[],
  fastPeriod: number,
  slowPeriod: number,
  signalPeriod: number
): { macdLine: number[]; signalLine: number[]; dates: string[] } | null {
  // Ensure enough data for the initial EMAs that form the MACD line
  if (!prices || prices.length < slowPeriod) {
    return null;
  }

  const orderedPrices = [...prices].reverse(); // oldest first for EMA calculation
  const closes = orderedPrices
    .map((p) => p.close)
    .filter((c): c is number => c != null);
  const originalDatesChronological = orderedPrices
    .map((p) => p.date)
    .filter((d): d is string => d != null);

  if (closes.length < slowPeriod) {
    // Not enough close prices after filtering
    return null;
  }

  const emaFastAll = calculateEMAValues(closes, fastPeriod);
  const emaSlowAll = calculateEMAValues(closes, slowPeriod);

  const macdLineFull: number[] = [];
  const macdDatesFull: string[] = [];

  // Calculate MACD line: emaFast - emaSlow
  // Both emaFastAll and emaSlowAll are same length as 'closes'
  // but EMAs only valid from their respective period onwards.
  // We need to align them starting from when *both* are valid.
  // The first valid MACD point is at index slowPeriod - 1 in 'closes' array.
  for (let i = slowPeriod - 1; i < closes.length; i++) {
    if (isNaN(emaFastAll[i]) || isNaN(emaSlowAll[i])) {
      // This might happen if initial data points were insufficient up to index i
      continue;
    }
    macdLineFull.push(emaFastAll[i] - emaSlowAll[i]);
    macdDatesFull.push(originalDatesChronological[i]);
  }

  if (macdLineFull.length < signalPeriod) {
    // Not enough MACD points to calculate signal line
    return null;
  }

  const signalLineFull = calculateEMAValues(macdLineFull, signalPeriod);

  // Now align macdLine with signalLine. Signal line starts signalPeriod-1 points into macdLineFull
  const finalMacdLine: number[] = [];
  const finalSignalLine: number[] = [];
  const finalDates: string[] = [];

  for (let i = signalPeriod - 1; i < macdLineFull.length; i++) {
    if (isNaN(signalLineFull[i])) {
      // signalLineFull corresponds index-wise to macdLineFull after its initial period
      continue;
    }
    finalMacdLine.push(macdLineFull[i]);
    finalSignalLine.push(signalLineFull[i]);
    finalDates.push(macdDatesFull[i]);
  }

  if (finalMacdLine.length < 2) {
    // Need at least T and T-1 for crossover detection
    return null;
  }

  // Reverse final arrays to have latest data first
  return {
    macdLine: finalMacdLine.reverse(),
    signalLine: finalSignalLine.reverse(),
    dates: finalDates.reverse(),
  };
}

// --- Internal Logic: Generate Signals for a Symbol ---
async function generateSignalsLogic(
  supabase: SupabaseClient,
  symbol: string
): Promise<{
  signals: MacdSignalInsert[];
  latestSignalDate?: string | null;
  error?: string;
}> {
  const signalsForSymbol: MacdSignalInsert[] = [];

  try {
    const { data: prices, error: dbError } = await supabase
      .from(HISTORICAL_PRICES_TABLE_NAME)
      .select("date, close")
      .eq("symbol", symbol)
      .order("date", { ascending: false })
      .limit(REQUIRED_DATA_POINTS_MACD);

    if (dbError) {
      return {
        signals: [],
        error: `Supabase fetch error for ${symbol}: ${dbError.message}`,
      };
    }
    const typedPrices = prices as PriceDataPoint[] | null;
    if (!typedPrices || typedPrices.length < REQUIRED_DATA_POINTS_MACD * 0.5) {
      // Heuristic check for very sparse data
      return {
        signals: [],
        error: `Insufficient historical price data for MACD for ${symbol}. Required ~${REQUIRED_DATA_POINTS_MACD}, got ${
          typedPrices?.length || 0
        }.`,
      };
    }

    const macdResult = calculateMACDAndSignalLine(
      typedPrices,
      MACD_FAST_PERIOD,
      MACD_SLOW_PERIOD,
      MACD_SIGNAL_PERIOD
    );

    if (
      !macdResult ||
      macdResult.macdLine.length < 2 ||
      macdResult.signalLine.length < 2 ||
      macdResult.dates.length < 2
    ) {
      return {
        signals: [],
        error: `Not enough MACD data points for T/T-1 comparison for ${symbol}. (Found ${
          macdResult?.macdLine.length || 0
        })`,
      };
    }

    const macdT = macdResult.macdLine[0];
    const signalT = macdResult.signalLine[0];
    const macdTminus1 = macdResult.macdLine[1];
    const signalTminus1 = macdResult.signalLine[1];
    const signalDate = macdResult.dates[0];

    let currentSignalCode: string | null = null;

    // Rule 1: MACD Line / Signal Line Cross
    if (macdT > signalT && macdTminus1 < signalTminus1)
      currentSignalCode = "MACD_CROSS_ABOVE";
    else if (macdT < signalT && macdTminus1 > signalTminus1)
      currentSignalCode = "MACD_CROSS_BELOW";

    if (currentSignalCode) {
      signalsForSymbol.push({
        signal_date: signalDate,
        symbol,
        signal_category: "technical",
        signal_type: "event",
        signal_code: currentSignalCode,
        details: {
          macd: macdT,
          signal: signalT,
          prev_macd: macdTminus1,
          prev_signal: signalTminus1,
        },
      });
    }

    // Rule 2: MACD Line / Zero Line Cross
    currentSignalCode = null; // Reset
    if (macdT > 0 && macdTminus1 < 0)
      currentSignalCode = "MACD_ZERO_CROSS_ABOVE";
    else if (macdT < 0 && macdTminus1 > 0)
      currentSignalCode = "MACD_ZERO_CROSS_BELOW";

    if (currentSignalCode) {
      signalsForSymbol.push({
        signal_date: signalDate,
        symbol,
        signal_category: "technical",
        signal_type: "event",
        signal_code: currentSignalCode,
        details: { macd: macdT, prev_macd: macdTminus1 },
      });
    }

    return { signals: signalsForSymbol, latestSignalDate: signalDate };
  } catch (e: unknown) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    return {
      signals: [],
      error: `Error generating MACD signals for ${symbol}: ${errorMessage}`,
    };
  }
}

// --- Internal Logic: Staleness Check ---
async function areSignalsStale(
  supabase: SupabaseClient,
  symbol: string
): Promise<boolean> {
  const { data: latestSignal, error } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .select("created_at")
    .eq("symbol", symbol)
    .in("signal_code", MACD_SIGNAL_CODES)
    .order("created_at", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error) {
    console.error(
      `[MacdSignalSvc] Error checking staleness for ${symbol}: ${error.message}. Assuming stale.`
    );
    return true;
  }
  if (!latestSignal?.created_at) return true;

  const lastGeneratedTime = new Date(latestSignal.created_at).getTime();
  const isStale = Date.now() - lastGeneratedTime >= MACD_SIGNALS_TTL_MS;
  if (!isStale) {
    console.log(
      `[MacdSignalSvc] MACD Signals for ${symbol} are fresh. Last generation: ${latestSignal.created_at}.`
    );
  }
  return isStale;
}

// --- Exported Service Function ---
export async function processMacdSignalsForSymbol(
  symbol: string,
  supabaseInstance?: SupabaseClient
): Promise<MacdProcessingResult> {
  const supabase = supabaseInstance || getSupabaseServerClient();
  const upperSymbol = symbol.toUpperCase();

  console.log(
    `[MacdSignalSvc] Processing MACD signals for symbol: ${upperSymbol}`
  );

  if (!(await areSignalsStale(supabase, upperSymbol))) {
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "skipped_fresh",
    };
  }

  console.log(
    `[MacdSignalSvc] MACD signals for ${upperSymbol} are stale or missing. Generating...`
  );
  const {
    signals,
    latestSignalDate,
    error: generationError,
  } = await generateSignalsLogic(supabase, upperSymbol);

  if (generationError) {
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "error",
      error: generationError,
      latestSignalDate,
    };
  }
  if (!signals || signals.length === 0) {
    console.log(
      `[MacdSignalSvc] No new MACD signals generated for ${upperSymbol}.`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "no_data_for_generation",
      latestSignalDate,
    };
  }

  const typedSignalsToInsert =
    signals as Database["public"]["Tables"]["signals"]["Insert"][];
  const { error: upsertError } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .upsert(typedSignalsToInsert, {
      onConflict: "symbol, signal_date, signal_code",
    });

  if (upsertError) {
    console.error(
      `[MacdSignalSvc] Error upserting signals for ${upperSymbol}: ${upsertError.message}`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "error",
      error: `Failed to upsert signals: ${upsertError.message}`,
      latestSignalDate,
    };
  }

  console.log(
    `[MacdSignalSvc] Successfully generated and upserted ${signals.length} MACD signals for ${upperSymbol}.`
  );
  return {
    processedSymbol: upperSymbol,
    signalsGenerated: signals.length,
    status: "processed",
    latestSignalDate,
  };
}
