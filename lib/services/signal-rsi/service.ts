// lib/services/signal-rsi/service.ts
import { SupabaseClient } from "@supabase/supabase-js";
import { getSupabaseServerClient } from "@/lib/supabase/serverClient";
import type { Database } from "@/lib/supabase/database.types";

// --- Types specific to this service ---
type HistoricalPrice = Database["public"]["Tables"]["historical_prices"]["Row"];
type PriceDataPoint = Pick<HistoricalPrice, "date" | "close">;

export type RsiSignalInsert = Omit<
  Database["public"]["Tables"]["signals"]["Insert"],
  "signal_category" | "signal_type"
> & {
  signal_category: "technical";
  signal_type: "state" | "event"; // RSI can generate both state and event signals
};

export interface RsiProcessingResult {
  processedSymbol: string;
  signalsGenerated: number;
  status: string; // e.g., "processed", "skipped_fresh", "no_data", "error"
  error?: string;
  latestSignalDate?: string | null;
}

// --- Configuration & Constants ---
const SIGNALS_TABLE_NAME = "signals";
const HISTORICAL_PRICES_TABLE_NAME = "historical_prices";

const RSI_PERIOD = 14;
const RSI_OVERBOUGHT_THRESHOLD = 70;
const RSI_OVERSOLD_THRESHOLD = 30;
// Fetch enough for T and T-1 RSI calculation + buffer for EMA-like smoothing in RSI
const REQUIRED_DATA_POINTS_RSI = RSI_PERIOD + 50 + 1;

// Signal codes generated by this service
const RSI_SIGNAL_CODES: string[] = [
  "RSI_OVERBOUGHT",
  "RSI_OVERSOLD",
  "RSI_ENTERED_OVERBOUGHT",
  "RSI_EXITED_OVERBOUGHT",
  "RSI_ENTERED_OVERSOLD",
  "RSI_EXITED_OVERSOLD",
];

// Time-to-live for these signals: 23 hours
export const RSI_SIGNALS_TTL_MS = 23 * 60 * 60 * 1000;

// --- RSI Calculation Helper (from original route) ---
// Calculates the RSI for the *most recent* point in the provided price data array
// Assumes prices are sorted DESC (latest first)
function calculateLatestRSIForService(
  pricesDesc: PriceDataPoint[], // Expects DESC sorted (latest first)
  period: number
): number | null {
  if (!pricesDesc || pricesDesc.length < period + 1) {
    // Need period+1 prices for 'period' changes
    return null;
  }

  const orderedPrices = [...pricesDesc].reverse(); // Reverse to chronological (oldest first)
  const closes = orderedPrices
    .map((p) => p.close)
    .filter((c): c is number => c != null);

  if (closes.length < period + 1) {
    return null;
  }

  let gains = 0;
  let losses = 0;

  // Calculate initial average gain/loss over the first 'period' changes
  for (let i = 1; i <= period; i++) {
    const diff = closes[i] - closes[i - 1];
    if (diff >= 0) {
      gains += diff;
    } else {
      losses -= diff; // Losses are positive
    }
  }

  if (period === 0) return null;
  let avgGain = gains / period;
  let avgLoss = losses / period;

  // Smooth averages for the rest of the data points
  for (let i = period + 1; i < closes.length; i++) {
    const diff = closes[i] - closes[i - 1];
    let currentGain = 0;
    let currentLoss = 0;
    if (diff >= 0) {
      currentGain = diff;
    } else {
      currentLoss = -diff;
    }
    avgGain = (avgGain * (period - 1) + currentGain) / period;
    avgLoss = (avgLoss * (period - 1) + currentLoss) / period;
  }

  if (avgLoss === 0) {
    return 100; // RSI is 100 if no losses (or avgLoss smoothed to 0)
  }
  if (avgGain === 0 && avgLoss > 0) {
    return 0; // RSI is 0 if no gains
  }

  const rs = avgGain / avgLoss;
  const rsi = 100 - 100 / (1 + rs);

  return parseFloat(rsi.toFixed(2));
}

// --- Internal Logic: Generate Signals for a Symbol ---
async function generateSignalsLogic(
  supabase: SupabaseClient,
  symbol: string
): Promise<{
  signals: RsiSignalInsert[];
  latestSignalDate?: string | null;
  error?: string;
}> {
  const signalsForSymbol: RsiSignalInsert[] = [];

  try {
    const { data: prices, error: dbError } = await supabase
      .from(HISTORICAL_PRICES_TABLE_NAME)
      .select("date, close")
      .eq("symbol", symbol)
      .order("date", { ascending: false })
      .limit(REQUIRED_DATA_POINTS_RSI);

    if (dbError) {
      return {
        signals: [],
        error: `Supabase fetch error for ${symbol}: ${dbError.message}`,
      };
    }

    const typedPrices = prices as PriceDataPoint[] | null;
    // For T-1 RSI, we need at least RSI_PERIOD+1 data points *after slicing*. So, RSI_PERIOD+2 overall.
    if (!typedPrices || typedPrices.length < RSI_PERIOD + 2) {
      return {
        signals: [],
        error: `Insufficient data (< ${
          RSI_PERIOD + 2
        } days) for T/T-1 RSI for ${symbol}. Found: ${
          typedPrices?.length || 0
        }`,
      };
    }

    const latestDataPoint = typedPrices[0];
    if (
      !latestDataPoint?.date ||
      latestDataPoint.close === null ||
      latestDataPoint.close === undefined
    ) {
      return {
        signals: [],
        error: `Latest data point for ${symbol} is invalid (missing date or close).`,
      };
    }
    const signalDate = latestDataPoint.date;

    const rsiT = calculateLatestRSIForService(typedPrices, RSI_PERIOD);
    const rsiTminus1 = calculateLatestRSIForService(
      typedPrices.slice(1),
      RSI_PERIOD
    );

    if (rsiT === null) {
      return {
        signals: [],
        error: `RSI calculation failed for T for ${symbol}.`,
        latestSignalDate: signalDate,
      };
    }

    let stateSignalCode: string | null = null;
    if (rsiT >= RSI_OVERBOUGHT_THRESHOLD) stateSignalCode = "RSI_OVERBOUGHT";
    else if (rsiT <= RSI_OVERSOLD_THRESHOLD) stateSignalCode = "RSI_OVERSOLD";

    if (stateSignalCode) {
      signalsForSymbol.push({
        signal_date: signalDate,
        symbol,
        signal_category: "technical",
        signal_type: "state",
        signal_code: stateSignalCode,
        details: {
          rsi: rsiT,
          close: latestDataPoint.close,
          threshold:
            stateSignalCode === "RSI_OVERBOUGHT"
              ? RSI_OVERBOUGHT_THRESHOLD
              : RSI_OVERSOLD_THRESHOLD,
        },
      });
    }

    if (rsiTminus1 !== null) {
      let eventSignalCode: string | null = null;
      if (
        rsiT >= RSI_OVERBOUGHT_THRESHOLD &&
        rsiTminus1 < RSI_OVERBOUGHT_THRESHOLD
      )
        eventSignalCode = "RSI_ENTERED_OVERBOUGHT";
      else if (
        rsiT < RSI_OVERBOUGHT_THRESHOLD &&
        rsiTminus1 >= RSI_OVERBOUGHT_THRESHOLD
      )
        eventSignalCode = "RSI_EXITED_OVERBOUGHT";
      else if (
        rsiT <= RSI_OVERSOLD_THRESHOLD &&
        rsiTminus1 > RSI_OVERSOLD_THRESHOLD
      )
        eventSignalCode = "RSI_ENTERED_OVERSOLD";
      else if (
        rsiT > RSI_OVERSOLD_THRESHOLD &&
        rsiTminus1 <= RSI_OVERSOLD_THRESHOLD
      )
        eventSignalCode = "RSI_EXITED_OVERSOLD";

      if (eventSignalCode) {
        signalsForSymbol.push({
          signal_date: signalDate,
          symbol,
          signal_category: "technical",
          signal_type: "event",
          signal_code: eventSignalCode,
          details: {
            rsi: rsiT,
            prev_rsi: rsiTminus1,
            close: latestDataPoint.close,
            threshold: eventSignalCode.includes("OVERBOUGHT")
              ? RSI_OVERBOUGHT_THRESHOLD
              : RSI_OVERSOLD_THRESHOLD,
          },
        });
      }
    } else {
      console.warn(
        `[RsiSignalSvc] RSI T-1 calculation failed for ${symbol}, skipping event signal generation.`
      );
    }

    return { signals: signalsForSymbol, latestSignalDate: signalDate };
  } catch (e: unknown) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    return {
      signals: [],
      error: `Error generating RSI signals for ${symbol}: ${errorMessage}`,
    };
  }
}

// --- Internal Logic: Staleness Check ---
async function areSignalsStale(
  supabase: SupabaseClient,
  symbol: string
): Promise<boolean> {
  const { data: latestSignal, error } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .select("created_at")
    .eq("symbol", symbol)
    .in("signal_code", RSI_SIGNAL_CODES)
    .order("created_at", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error) {
    console.error(
      `[RsiSignalSvc] Error checking staleness for ${symbol}: ${error.message}. Assuming stale.`
    );
    return true;
  }
  if (!latestSignal?.created_at) return true;

  const lastGeneratedTime = new Date(latestSignal.created_at).getTime();
  const isStale = Date.now() - lastGeneratedTime >= RSI_SIGNALS_TTL_MS;
  if (!isStale) {
    console.log(
      `[RsiSignalSvc] RSI Signals for ${symbol} are fresh. Last generation: ${latestSignal.created_at}.`
    );
  }
  return isStale;
}

// --- Exported Service Function ---
export async function processRsiSignalsForSymbol(
  symbol: string,
  supabaseInstance?: SupabaseClient
): Promise<RsiProcessingResult> {
  const supabase = supabaseInstance || getSupabaseServerClient();
  const upperSymbol = symbol.toUpperCase();

  console.log(
    `[RsiSignalSvc] Processing RSI signals for symbol: ${upperSymbol}`
  );

  if (!(await areSignalsStale(supabase, upperSymbol))) {
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "skipped_fresh",
    };
  }

  console.log(
    `[RsiSignalSvc] RSI signals for ${upperSymbol} are stale or missing. Generating...`
  );
  const {
    signals,
    latestSignalDate,
    error: generationError,
  } = await generateSignalsLogic(supabase, upperSymbol);

  if (generationError) {
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "error",
      error: generationError,
      latestSignalDate,
    };
  }
  if (!signals || signals.length === 0) {
    console.log(
      `[RsiSignalSvc] No new RSI signals generated for ${upperSymbol}.`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "no_data_for_generation",
      latestSignalDate,
    };
  }

  const typedSignalsToInsert =
    signals as Database["public"]["Tables"]["signals"]["Insert"][];
  const { error: upsertError } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .upsert(typedSignalsToInsert, {
      onConflict: "symbol, signal_date, signal_code",
    });

  if (upsertError) {
    console.error(
      `[RsiSignalSvc] Error upserting signals for ${upperSymbol}: ${upsertError.message}`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "error",
      error: `Failed to upsert signals: ${upsertError.message}`,
      latestSignalDate,
    };
  }

  console.log(
    `[RsiSignalSvc] Successfully generated and upserted ${signals.length} RSI signals for ${upperSymbol}.`
  );
  return {
    processedSymbol: upperSymbol,
    signalsGenerated: signals.length,
    status: "processed",
    latestSignalDate,
  };
}
