// lib/services/signal-sma/service.ts
import { SupabaseClient } from "@supabase/supabase-js";
import { getSupabaseServerClient } from "@/lib/supabase/serverClient";
import type { Database } from "@/lib/supabase/database.types";
import { generateSmaSignals as generateSmaSignalsCore } from "./fetch"; // Import core logic

// Define a consistent processing result type for SMA signals
export interface SmaProcessingResult {
  processedSymbol: string;
  signalsGenerated: number;
  status: string; // e.g., "processed", "skipped_fresh", "no_data_for_generation", "error"
  error?: string;
  latestSignalDate?: string | null; // Date of the data point used for the signal
}

const SIGNALS_TABLE_NAME = "signals";

// Signal codes generated by the SMA service (used for staleness check)
const SMA_SIGNAL_CODES: string[] = [
  "PRICE_POS_RANK_%", // Pattern for rank signals (state)
  "SMA50_CROSS_ABOVE", // Event
  "SMA50_CROSS_BELOW", // Event
  "SMA200_CROSS_ABOVE", // Event
  "SMA200_CROSS_BELOW", // Event
];

// Time-to-live for SMA signals: 23 hours (to refresh daily)
export const SMA_SIGNALS_TTL_MS = 23 * 60 * 60 * 1000;

// --- Internal Logic: Staleness Check ---
async function areSmaSignalsStale(
  supabase: SupabaseClient,
  symbol: string
): Promise<boolean> {
  const orConditions = SMA_SIGNAL_CODES.map((code) =>
    code.includes("%") ? `signal_code.like.${code}` : `signal_code.eq.${code}`
  ).join(",");

  const { data: latestSignal, error } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .select("created_at")
    .eq("symbol", symbol)
    .or(orConditions)
    .order("created_at", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error) {
    console.error(
      `[SmaSignalSvc] Error checking staleness for ${symbol}: ${error.message}. Assuming stale.`
    );
    return true; // Assume stale on error to be safe
  }

  if (!latestSignal?.created_at) {
    // No existing SMA signals of this type found for this symbol
    return true;
  }

  const lastGeneratedTime = new Date(latestSignal.created_at).getTime();
  const isStale = Date.now() - lastGeneratedTime >= SMA_SIGNALS_TTL_MS;

  if (!isStale) {
    console.log(
      `[SmaSignalSvc] SMA signals for ${symbol} are fresh. Last generation: ${latestSignal.created_at}.`
    );
  }
  return isStale;
}

// --- Exported Service Function ---
/**
 * Processes SMA signals for a single symbol.
 * Checks for staleness specific to SMA signals before generating.
 * @param symbol The stock symbol to process.
 * @param supabaseInstance Optional Supabase client instance.
 * @returns Promise<SmaProcessingResult> Result of the processing.
 */
export async function processSmaSignalsForSymbol(
  symbol: string,
  supabaseInstance?: SupabaseClient
): Promise<SmaProcessingResult> {
  // Note: generateSmaSignalsCore from fetch.ts creates its own Supabase client internally.
  // This service uses its own (passed or new) client for staleness check and upsert.
  const supabase = supabaseInstance || getSupabaseServerClient();
  const upperSymbol = symbol.toUpperCase();

  console.log(
    `[SmaSignalSvc] Processing SMA signals for symbol: ${upperSymbol}`
  );

  if (!(await areSmaSignalsStale(supabase, upperSymbol))) {
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "skipped_fresh",
    };
  }

  console.log(
    `[SmaSignalSvc] SMA signals for ${upperSymbol} are stale or missing. Generating...`
  );

  // Call the core generation function from fetch.ts.
  // It's called without a targetDate, so it processes the latest available data.
  // It returns { generatedSignals: SmaSignalDbInsert[]; error: string | null }
  const { generatedSignals, error: generationError } =
    await generateSmaSignalsCore(upperSymbol);

  let latestSignalDateFromResult: string | null = null;
  if (
    generatedSignals &&
    generatedSignals.length > 0 &&
    generatedSignals[0].signal_date
  ) {
    // All signals from a single run of generateSmaSignalsCore share the same signal_date
    latestSignalDateFromResult = generatedSignals[0].signal_date;
  }

  // If generateSmaSignalsCore indicates an error (e.g., no data, DB error during fetch)
  if (generationError) {
    console.error(
      `[SmaSignalSvc] Error during SMA signal generation core logic for ${upperSymbol}: ${generationError}`
    );
    // Even if there's an error, generatedSignals might have partial data or be an empty array.
    // The `error` string from generateSmaSignalsCore is the primary indicator of a problem.
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: generatedSignals?.length || 0, // Report any signals that might have been generated before the error
      status: "error",
      error: generationError, // This error comes from the core generation logic
      latestSignalDate: latestSignalDateFromResult,
    };
  }

  // If no error, but no signals were generated (e.g., insufficient data points for calculation)
  if (!generatedSignals || generatedSignals.length === 0) {
    console.log(
      `[SmaSignalSvc] No new SMA signals generated by core logic for ${upperSymbol} (e.g., insufficient data).`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "no_data_for_generation", // Or a more specific status if generateSmaSignalsCore provided one
      latestSignalDate: latestSignalDateFromResult,
    };
  }

  // Upsert signals
  // The SmaSignalDbInsert type should be compatible with the generic signals table Insert type
  const typedSignalsToInsert =
    generatedSignals as Database["public"]["Tables"]["signals"]["Insert"][];
  const { error: upsertError } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .upsert(typedSignalsToInsert, {
      onConflict: "symbol, signal_date, signal_code",
    });

  if (upsertError) {
    console.error(
      `[SmaSignalSvc] Error upserting SMA signals for ${upperSymbol}: ${upsertError.message}`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0, // Or generatedSignals.length to show what was attempted
      status: "error",
      error: `Failed to upsert SMA signals: ${upsertError.message}`,
      latestSignalDate: latestSignalDateFromResult,
    };
  }

  console.log(
    `[SmaSignalSvc] Successfully generated and upserted ${generatedSignals.length} SMA signals for ${upperSymbol}.`
  );
  return {
    processedSymbol: upperSymbol,
    signalsGenerated: generatedSignals.length,
    status: "processed",
    latestSignalDate: latestSignalDateFromResult,
  };
}
