// lib/services/signal-analyst-consensus/service.ts
import { SupabaseClient } from "@supabase/supabase-js";
import { getSupabaseServerClient } from "@/lib/supabase/serverClient"; // For default client
import type { Database } from "@/lib/supabase/database.types";

// --- Types specific to this service ---
type GradesConsensusRow =
  Database["public"]["Tables"]["grades_consensus"]["Row"];

export type AnalystSignalInsert = Omit<
  Database["public"]["Tables"]["signals"]["Insert"],
  "signal_category" | "signal_type"
> & {
  signal_category: "sentiment";
  signal_type: "event" | "state";
};

export interface AnalystProcessingResult {
  processedSymbol: string;
  signalsGenerated: number;
  status: string; // e.g., "processed", "skipped_fresh", "no_data", "error"
  error?: string;
}

// --- Configuration & Constants ---
const SIGNALS_TABLE_NAME = "signals";
const GRADES_CONSENSUS_TABLE_NAME = "grades_consensus";

// Signal codes generated by this service (used for staleness check)
const ANALYST_SIGNAL_CODES: string[] = [
  "ANALYST_CONSENSUS_RANK_%", // Pattern for rank signals
  "ANALYST_CONSENSUS_UPGRADE",
  "ANALYST_CONSENSUS_DOWNGRADE",
];

// Time-to-live for these signals: 23 hours (to refresh daily)
// Adjust if analyst data updates less frequently.
export const ANALYST_SIGNALS_TTL_MS = 23 * 60 * 60 * 1000;

// --- Helper: Map consensus string to rank ---
const consensusRankMap: { [key: string]: number } = {
  "Strong Buy": 5,
  Buy: 4,
  Hold: 3,
  Sell: 2,
  "Strong Sell": 1,
};

function getConsensusRank(consensus?: string | null): number | null {
  if (!consensus) return null;
  return consensusRankMap[consensus] ?? null;
}

// --- Internal Logic: Generate Signals for a Symbol ---
async function generateSignalsLogic(
  supabase: SupabaseClient,
  symbol: string
): Promise<{ signals: AnalystSignalInsert[]; error?: string }> {
  const signalsToInsert: AnalystSignalInsert[] = [];

  try {
    const { data: consensusHistory, error: dbError } = await supabase
      .from(GRADES_CONSENSUS_TABLE_NAME)
      .select("*")
      .eq("symbol", symbol)
      .order("date", { ascending: false })
      .limit(2);

    if (dbError) {
      return {
        signals: [],
        error: `Supabase fetch error for ${symbol} from ${GRADES_CONSENSUS_TABLE_NAME}: ${dbError.message}`,
      };
    }

    if (!consensusHistory || consensusHistory.length < 1) {
      return { signals: [] }; // No data, not an error for generation itself
    }

    const currentData = consensusHistory[0] as GradesConsensusRow;
    const previousData =
      consensusHistory.length >= 2
        ? (consensusHistory[1] as GradesConsensusRow)
        : null;

    const signalDate = currentData.date;

    // Signal 1: Current Consensus State (Rank)
    const currentRank = getConsensusRank(currentData.consensus);
    if (currentRank !== null && currentData.consensus) {
      signalsToInsert.push({
        signal_date: signalDate,
        symbol: symbol,
        signal_category: "sentiment",
        signal_type: "state",
        signal_code: `ANALYST_CONSENSUS_RANK_${currentRank}`,
        details: {
          consensus: currentData.consensus,
          rank: currentRank,
          strong_buy: currentData.strong_buy,
          buy: currentData.buy,
          hold: currentData.hold,
          sell: currentData.sell,
          strong_sell: currentData.strong_sell,
        },
      });
    }

    // Signal 2: Change Event (Upgrade/Downgrade)
    if (
      previousData &&
      currentData.consensus &&
      previousData.consensus &&
      currentData.consensus !== previousData.consensus
    ) {
      const previousRank = getConsensusRank(previousData.consensus);
      if (
        currentRank !== null &&
        previousRank !== null &&
        currentRank !== previousRank
      ) {
        const signalCode =
          currentRank > previousRank
            ? "ANALYST_CONSENSUS_UPGRADE"
            : "ANALYST_CONSENSUS_DOWNGRADE";
        signalsToInsert.push({
          signal_date: signalDate,
          symbol: symbol,
          signal_category: "sentiment",
          signal_type: "event",
          signal_code: signalCode,
          details: {
            previous_consensus: previousData.consensus,
            current_consensus: currentData.consensus,
            previous_rank: previousRank,
            current_rank: currentRank,
            previous_date: previousData.date, // Important context
          },
        });
      }
    }
    return { signals: signalsToInsert };
  } catch (e: unknown) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    return {
      signals: [],
      error: `Error generating analyst signals for ${symbol}: ${errorMessage}`,
    };
  }
}

// --- Internal Logic: Staleness Check ---
async function areSignalsStale(
  supabase: SupabaseClient,
  symbol: string
): Promise<boolean> {
  const orConditions = ANALYST_SIGNAL_CODES.map((code) =>
    code.includes("%") ? `signal_code.like.${code}` : `signal_code.eq.${code}`
  ).join(",");

  const { data: latestSignal, error } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .select("created_at")
    .eq("symbol", symbol)
    .or(orConditions)
    .order("created_at", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error) {
    console.error(
      `[AnalystSignalSvc] Error checking staleness for ${symbol}: ${error.message}. Assuming stale.`
    );
    return true; // Assume stale on error to be safe
  }

  if (!latestSignal?.created_at) {
    return true; // No existing signals of this type found, so it's "stale" (needs generation)
  }

  const lastGeneratedTime = new Date(latestSignal.created_at).getTime();
  const isStale = Date.now() - lastGeneratedTime >= ANALYST_SIGNALS_TTL_MS;
  if (!isStale) {
    console.log(
      `[AnalystSignalSvc] Signals for ${symbol} are fresh. Last generation: ${latestSignal.created_at}.`
    );
  }
  return isStale;
}

// --- Exported Service Function ---
/**
 * Processes analyst consensus signals for a single symbol.
 * Checks for staleness specific to analyst signals before generating.
 * @param symbol The stock symbol to process.
 * @param supabaseInstance Optional Supabase client instance.
 * @returns Promise<AnalystProcessingResult> Result of the processing.
 */
export async function processAnalystConsensusForSymbol(
  symbol: string,
  supabaseInstance?: SupabaseClient
): Promise<AnalystProcessingResult> {
  const supabase = supabaseInstance || getSupabaseServerClient();
  const upperSymbol = symbol.toUpperCase();

  console.log(
    `[AnalystSignalSvc] Processing analyst consensus for symbol: ${upperSymbol}`
  );

  if (!(await areSignalsStale(supabase, upperSymbol))) {
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "skipped_fresh",
    };
  }

  console.log(
    `[AnalystSignalSvc] Signals for ${upperSymbol} are stale or missing. Generating...`
  );
  const { signals, error: generationError } = await generateSignalsLogic(
    supabase,
    upperSymbol
  );

  if (generationError) {
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "error",
      error: generationError,
    };
  }

  if (!signals || signals.length === 0) {
    // This can happen if there's no consensus data for the symbol
    console.log(
      `[AnalystSignalSvc] No new analyst signals generated for ${upperSymbol} (likely no source data).`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "no_data_for_generation",
    };
  }

  // Upsert signals
  const typedSignalsToInsert =
    signals as Database["public"]["Tables"]["signals"]["Insert"][];
  const { error: upsertError } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .upsert(typedSignalsToInsert, {
      onConflict: "symbol, signal_date, signal_code",
    });

  if (upsertError) {
    console.error(
      `[AnalystSignalSvc] Error upserting signals for ${upperSymbol}: ${upsertError.message}`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0, // Or signals.length if you want to count what was attempted
      status: "error",
      error: `Failed to upsert signals: ${upsertError.message}`,
    };
  }

  console.log(
    `[AnalystSignalSvc] Successfully generated and upserted ${signals.length} signals for ${upperSymbol}.`
  );
  return {
    processedSymbol: upperSymbol,
    signalsGenerated: signals.length,
    status: "processed",
  };
}
