// lib/services/signal-ema/service.ts
import { SupabaseClient } from "@supabase/supabase-js";
import { getSupabaseServerClient } from "@/lib/supabase/serverClient";
import type { Database } from "@/lib/supabase/database.types";

// --- Types specific to this service ---
type HistoricalPrice = Database["public"]["Tables"]["historical_prices"]["Row"];
type PriceDataPoint = Pick<HistoricalPrice, "date" | "close">;

export type EmaSignalInsert = Omit<
  Database["public"]["Tables"]["signals"]["Insert"],
  "signal_category" | "signal_type"
> & {
  signal_category: "technical";
  signal_type: "event"; // EMA crosses are events
};

type MovingAverageValues = { [period: number]: number | undefined };

export interface EmaProcessingResult {
  processedSymbol: string;
  signalsGenerated: number;
  status: string; // e.g., "processed", "skipped_fresh", "no_data", "error"
  error?: string;
  latestSignalDate?: string | null; // To indicate the date of data used
}

// --- Configuration & Constants ---
const SIGNALS_TABLE_NAME = "signals";
const HISTORICAL_PRICES_TABLE_NAME = "historical_prices";

const EMAs_REQUIRED: number[] = [50, 200];
const LONGEST_MA_PERIOD: number = Math.max(...EMAs_REQUIRED);
// Need enough data for longest EMA + lookback for EMA stability + T-1 comparison
const REQUIRED_DATA_POINTS: number = LONGEST_MA_PERIOD + 50 + 1; // Buffer + T-1

// Signal codes generated by this service
const EMA_SIGNAL_CODES: string[] = [
  "EMA50_CROSS_ABOVE",
  "EMA50_CROSS_BELOW",
  "EMA200_CROSS_ABOVE",
  "EMA200_CROSS_BELOW",
];

// Time-to-live for these signals: 23 hours (to refresh daily based on new price data)
export const EMA_SIGNALS_TTL_MS = 23 * 60 * 60 * 1000;

// --- EMA Calculation Helpers (from original route) ---
function calculateEMAValues(values: number[], period: number): number[] {
  if (!values || values.length < period || period <= 0) return [];
  const k = 2 / (period + 1);
  const emaArray: number[] = [];
  // Initial SMA
  let sum = 0;
  for (let i = 0; i < period; i++) {
    sum += values[i];
  }
  emaArray[period - 1] = sum / period; // EMA for the 'period'-th day is its SMA

  // Subsequent EMAs
  for (let i = period; i < values.length; i++) {
    // Ensure emaArray[i-1] is valid. This check might be slightly off if period-1 is the first index.
    // The first EMA is at index period-1 using data points 0 to period-1.
    // The next EMA uses values[i] and emaArray[i-1] (which corresponds to the previous EMA value).
    const previousEma = emaArray[i - 1]; // this should correspond to the EMA of the previous data point in 'values'
    const ema = values[i] * k + previousEma * (1 - k);
    emaArray[i] = ema;
  }
  return emaArray.slice(period - 1); // Return all calculated EMAs starting from the first one
}

function calculateEMAsFromSortedPrices(
  prices: PriceDataPoint[], // Assumed sorted DESC (latest first)
  periods: number[]
): MovingAverageValues {
  const calculatedEMAs: MovingAverageValues = {};
  if (!prices || prices.length === 0) return calculatedEMAs;

  // Reverse to be chronological (oldest first) for calculateEMAValues
  const orderedPrices = [...prices].reverse();
  const closes = orderedPrices
    .map((p) => p.close)
    .filter((c): c is number => c != null); // Ensure only numbers

  for (const period of periods) {
    if (closes.length >= period) {
      const emaArray = calculateEMAValues(closes, period);
      if (emaArray.length > 0) {
        // The last value in emaArray corresponds to the latest EMA
        calculatedEMAs[period] = parseFloat(
          emaArray[emaArray.length - 1].toFixed(2)
        );
      }
    }
  }
  return calculatedEMAs;
}

// --- Internal Logic: Generate Signals for a Symbol ---
async function generateSignalsLogic(
  supabase: SupabaseClient,
  symbol: string
): Promise<{
  signals: EmaSignalInsert[];
  latestSignalDate?: string | null;
  error?: string;
}> {
  const signalsForSymbol: EmaSignalInsert[] = [];

  try {
    const { data: prices, error: dbError } = await supabase
      .from(HISTORICAL_PRICES_TABLE_NAME)
      .select("date, close")
      .eq("symbol", symbol)
      .order("date", { ascending: false })
      .limit(REQUIRED_DATA_POINTS);

    if (dbError) {
      return {
        signals: [],
        error: `Supabase fetch error for ${symbol}: ${dbError.message}`,
      };
    }
    if (!prices || prices.length < 2) {
      // Need at least T and T-1
      return {
        signals: [],
        error: `Insufficient historical price data (< 2 days) for ${symbol}. Found ${
          prices?.length || 0
        }.`,
      };
    }

    const typedPrices = prices as PriceDataPoint[];
    const dataT = typedPrices[0]; // Latest data point
    const dataTminus1 = typedPrices[1]; // Previous data point

    if (
      !dataT.date ||
      dataT.close === null ||
      dataT.close === undefined ||
      !dataTminus1.date ||
      dataTminus1.close === null ||
      dataTminus1.close === undefined
    ) {
      return {
        signals: [],
        error: `Missing date or close price in latest data points for ${symbol}.`,
      };
    }
    const signalDate = dataT.date;
    const closeT = dataT.close;
    const closeTminus1 = dataTminus1.close;

    // Calculate EMAs for T and T-1
    const emasT = calculateEMAsFromSortedPrices(typedPrices, EMAs_REQUIRED);
    const emasTminus1 = calculateEMAsFromSortedPrices(
      typedPrices.slice(1),
      EMAs_REQUIRED
    );

    // Rule 1: EMA 50 Cross
    const ema50T = emasT[50];
    const ema50Tminus1 = emasTminus1[50];
    if (ema50T != null && ema50Tminus1 != null) {
      let signalCode: string | null = null;
      if (closeT > ema50T && closeTminus1 < ema50Tminus1)
        signalCode = "EMA50_CROSS_ABOVE";
      else if (closeT < ema50T && closeTminus1 > ema50Tminus1)
        signalCode = "EMA50_CROSS_BELOW";

      if (signalCode) {
        signalsForSymbol.push({
          signal_date: signalDate,
          symbol,
          signal_category: "technical",
          signal_type: "event",
          signal_code: signalCode,
          details: {
            close: closeT,
            ema50: ema50T,
            prev_close: closeTminus1,
            prev_ema50: ema50Tminus1,
          },
        });
      }
    }

    // Rule 2: EMA 200 Cross
    const ema200T = emasT[200];
    const ema200Tminus1 = emasTminus1[200];
    if (ema200T != null && ema200Tminus1 != null) {
      let signalCode: string | null = null;
      if (closeT > ema200T && closeTminus1 < ema200Tminus1)
        signalCode = "EMA200_CROSS_ABOVE";
      else if (closeT < ema200T && closeTminus1 > ema200Tminus1)
        signalCode = "EMA200_CROSS_BELOW";

      if (signalCode) {
        signalsForSymbol.push({
          signal_date: signalDate,
          symbol,
          signal_category: "technical",
          signal_type: "event",
          signal_code: signalCode,
          details: {
            close: closeT,
            ema200: ema200T,
            prev_close: closeTminus1,
            prev_ema200: ema200Tminus1,
          },
        });
      }
    }
    // Placeholder for Golden/Death Cross (EMA50 vs EMA200) if needed in the future

    return { signals: signalsForSymbol, latestSignalDate: signalDate };
  } catch (e: unknown) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    return {
      signals: [],
      error: `Error generating EMA signals for ${symbol}: ${errorMessage}`,
    };
  }
}

// --- Internal Logic: Staleness Check ---
async function areSignalsStale(
  supabase: SupabaseClient,
  symbol: string
): Promise<boolean> {
  const { data: latestSignal, error } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .select("created_at")
    .eq("symbol", symbol)
    .in("signal_code", EMA_SIGNAL_CODES)
    .order("created_at", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error) {
    console.error(
      `[EmaSignalSvc] Error checking staleness for ${symbol}: ${error.message}. Assuming stale.`
    );
    return true;
  }
  if (!latestSignal?.created_at) return true; // No existing signals of this type

  const lastGeneratedTime = new Date(latestSignal.created_at).getTime();
  const isStale = Date.now() - lastGeneratedTime >= EMA_SIGNALS_TTL_MS;
  if (!isStale) {
    console.log(
      `[EmaSignalSvc] EMA Signals for ${symbol} are fresh. Last generation: ${latestSignal.created_at}.`
    );
  }
  return isStale;
}

// --- Exported Service Function ---
export async function processEmaSignalsForSymbol(
  symbol: string,
  supabaseInstance?: SupabaseClient
): Promise<EmaProcessingResult> {
  const supabase = supabaseInstance || getSupabaseServerClient();
  const upperSymbol = symbol.toUpperCase();

  console.log(
    `[EmaSignalSvc] Processing EMA signals for symbol: ${upperSymbol}`
  );

  if (!(await areSignalsStale(supabase, upperSymbol))) {
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "skipped_fresh",
    };
  }

  console.log(
    `[EmaSignalSvc] EMA signals for ${upperSymbol} are stale or missing. Generating...`
  );
  const {
    signals,
    latestSignalDate,
    error: generationError,
  } = await generateSignalsLogic(supabase, upperSymbol);

  if (generationError) {
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "error",
      error: generationError,
      latestSignalDate,
    };
  }
  if (!signals || signals.length === 0) {
    console.log(
      `[EmaSignalSvc] No new EMA signals generated for ${upperSymbol}.`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "no_data_for_generation",
      latestSignalDate,
    };
  }

  const typedSignalsToInsert =
    signals as Database["public"]["Tables"]["signals"]["Insert"][];
  const { error: upsertError } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .upsert(typedSignalsToInsert, {
      onConflict: "symbol, signal_date, signal_code",
    });

  if (upsertError) {
    console.error(
      `[EmaSignalSvc] Error upserting signals for ${upperSymbol}: ${upsertError.message}`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "error",
      error: `Failed to upsert signals: ${upsertError.message}`,
      latestSignalDate,
    };
  }

  console.log(
    `[EmaSignalSvc] Successfully generated and upserted ${signals.length} EMA signals for ${upperSymbol}.`
  );
  return {
    processedSymbol: upperSymbol,
    signalsGenerated: signals.length,
    status: "processed",
    latestSignalDate,
  };
}
