// lib/services/signal-earnings/service.ts
import { SupabaseClient } from "@supabase/supabase-js";
import { getSupabaseServerClient } from "@/lib/supabase/serverClient";
import type { Database, Json } from "@/lib/supabase/database.types";

// --- Types specific to this service ---
type EarningsCalendarRow =
  Database["public"]["Tables"]["earnings_calendar"]["Row"];

export type EarningsSignalInsert = Omit<
  Database["public"]["Tables"]["signals"]["Insert"],
  "signal_category" | "signal_type"
> & {
  signal_category: "fundamental";
  signal_type: "event";
};

export interface EarningsProcessingResult {
  processedSymbol: string;
  signalsGenerated: number;
  status: string; // e.g., "processed", "skipped_fresh", "no_data", "error"
  error?: string;
}

// --- Configuration & Constants ---
const SIGNALS_TABLE_NAME = "signals";
const EARNINGS_CALENDAR_TABLE_NAME = "earnings_calendar";

const LOOKBACK_DAYS = 90; // How far back to fetch earnings data for reported events
const UPCOMING_EARNINGS_CODE = "EARNINGS_UPCOMING";

// Signal codes generated by this service (used for staleness check)
const EARNINGS_SIGNAL_CODES: string[] = [
  "EARNINGS_BEAT_EPS",
  "EARNINGS_MISS_EPS",
  "EARNINGS_MEET_EPS",
  "EARNINGS_REPORTED_EPS",
  "EARNINGS_BEAT_REVENUE",
  "EARNINGS_MISS_REVENUE",
  "EARNINGS_MEET_REVENUE",
  "EARNINGS_REPORTED_REVENUE",
  UPCOMING_EARNINGS_CODE,
];

// Time-to-live for these signals: 23 hours (to refresh daily snapshot of earnings events)
export const EARNINGS_SIGNALS_TTL_MS = 23 * 60 * 60 * 1000;

// --- Internal Logic: Generate Signals for a Symbol ---
async function generateSignalsLogic(
  supabase: SupabaseClient,
  symbol: string,
  today: Date, // Pass Date object for precise calculations
  todayStr: string // Pass today's date string for DB consistency
): Promise<{ signals: EarningsSignalInsert[]; error?: string }> {
  const signalsToInsert: EarningsSignalInsert[] = [];
  const uniqueSignalKeysForSymbolRun = new Set<string>(); // To handle specific cases within this symbol's processing if needed

  try {
    const lookbackDate = new Date(today);
    lookbackDate.setDate(today.getDate() - LOOKBACK_DAYS);
    const lookbackDateStr = lookbackDate.toISOString().split("T")[0];

    const { data: calendarData, error: calendarError } = await supabase
      .from(EARNINGS_CALENDAR_TABLE_NAME)
      .select(
        "symbol, date, eps_actual, eps_estimated, revenue_actual, revenue_estimated"
      )
      .eq("symbol", symbol)
      .gte("date", lookbackDateStr) // Fetch all from lookback date for this symbol
      .order("date", { ascending: true }); // Process chronologically if needed, though not strictly necessary here

    if (calendarError) {
      return {
        signals: [],
        error: `Supabase fetch error for ${symbol} from ${EARNINGS_CALENDAR_TABLE_NAME}: ${calendarError.message}`,
      };
    }

    if (!calendarData || calendarData.length === 0) {
      return { signals: [] }; // No relevant calendar data for this symbol
    }

    for (const earning of calendarData) {
      const typedEarning = earning as Pick<
        EarningsCalendarRow,
        | "symbol"
        | "date"
        | "eps_actual"
        | "eps_estimated"
        | "revenue_actual"
        | "revenue_estimated"
      >;

      // Should always have symbol from eq filter, date should be there
      if (!typedEarning.date) continue;

      const {
        date: earningsDate, // This is the actual earnings announcement date
        eps_actual,
        eps_estimated,
        revenue_actual,
        revenue_estimated,
      } = typedEarning;

      // All signals generated by this service will have signal_date = todayStr
      const signalDateForDb = todayStr;

      const isReported = eps_actual !== null || revenue_actual !== null;
      const isConsideredUpcoming = !isReported && earningsDate >= todayStr;

      // --- Process Reported Earnings ---
      if (isReported && earningsDate <= todayStr) {
        // Only process if reported on or before today
        let epsSignalCode: string | null = null;
        let revSignalCode: string | null = null;

        if (eps_actual !== null) {
          if (eps_estimated !== null) {
            epsSignalCode =
              eps_actual > eps_estimated
                ? "EARNINGS_BEAT_EPS"
                : eps_actual < eps_estimated
                ? "EARNINGS_MISS_EPS"
                : "EARNINGS_MEET_EPS";
          } else {
            epsSignalCode = "EARNINGS_REPORTED_EPS";
          }
        }

        if (revenue_actual !== null) {
          if (revenue_estimated !== null) {
            revSignalCode =
              revenue_actual > revenue_estimated
                ? "EARNINGS_BEAT_REVENUE"
                : revenue_actual < revenue_estimated
                ? "EARNINGS_MISS_REVENUE"
                : "EARNINGS_MEET_REVENUE";
          } else {
            revSignalCode = "EARNINGS_REPORTED_REVENUE";
          }
        }

        if (epsSignalCode) {
          const signalKey = `${symbol}-${signalDateForDb}-${epsSignalCode}-${earningsDate}`; // Include earningsDate for uniqueness if multiple reports processed today
          if (!uniqueSignalKeysForSymbolRun.has(signalKey)) {
            signalsToInsert.push({
              signal_date: signalDateForDb,
              symbol: symbol,
              signal_category: "fundamental",
              signal_type: "event",
              signal_code: epsSignalCode,
              details: {
                reported_date: earningsDate,
                eps_actual,
                eps_estimated,
              },
            });
            uniqueSignalKeysForSymbolRun.add(signalKey);
          }
        }

        if (revSignalCode) {
          const signalKey = `${symbol}-${signalDateForDb}-${revSignalCode}-${earningsDate}`;
          if (!uniqueSignalKeysForSymbolRun.has(signalKey)) {
            signalsToInsert.push({
              signal_date: signalDateForDb,
              symbol: symbol,
              signal_category: "fundamental",
              signal_type: "event",
              signal_code: revSignalCode,
              details: {
                reported_date: earningsDate,
                revenue_actual,
                revenue_estimated,
              },
            });
            uniqueSignalKeysForSymbolRun.add(signalKey);
          }
        }
      }
      // --- Process Upcoming Earnings ---
      else if (isConsideredUpcoming) {
        // earningsDate >= todayStr and not reported
        const signalCode = UPCOMING_EARNINGS_CODE;
        // Ensure earningsDate is treated as a date string in the user's local timezone for day calculation
        // The `+ 'T00:00:00Z'` might be problematic if earningsDate is not already just YYYY-MM-DD.
        // Assuming earningsDate is 'YYYY-MM-DD'.
        const earningsDateObj = new Date(earningsDate + "T00:00:00"); // Treat as midnight in local timezone for comparison
        const todayAtMidnight = new Date(todayStr + "T00:00:00");

        const daysUntil = Math.max(
          0,
          Math.round(
            // Ensure non-negative
            (earningsDateObj.getTime() - todayAtMidnight.getTime()) /
              (1000 * 60 * 60 * 24)
          )
        );

        const signalDetails: Json = {
          earnings_date: earningsDate,
          days_until: daysUntil,
        };
        const signalKey = `${symbol}-${signalDateForDb}-${signalCode}-${earningsDate}`; // Upcoming for a specific date
        if (!uniqueSignalKeysForSymbolRun.has(signalKey)) {
          signalsToInsert.push({
            signal_date: signalDateForDb,
            symbol: symbol,
            signal_category: "fundamental",
            signal_type: "event",
            signal_code: signalCode,
            details: signalDetails,
          });
          uniqueSignalKeysForSymbolRun.add(signalKey);
        }
      }
    }
    return { signals: signalsToInsert };
  } catch (e: unknown) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    return {
      signals: [],
      error: `Error generating earnings signals for ${symbol}: ${errorMessage}`,
    };
  }
}

// --- Internal Logic: Staleness Check ---
async function areSignalsStale(
  supabase: SupabaseClient,
  symbol: string
): Promise<boolean> {
  // For earnings, staleness means we haven't generated signals for this symbol *today* (or within TTL)
  // The signal_date of generated signals is todayStr.
  // We check created_at to see if the *process* ran recently.
  const { data: latestSignal, error } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .select("created_at")
    .eq("symbol", symbol)
    .in("signal_code", EARNINGS_SIGNAL_CODES) // Check against all codes this service might generate
    .order("created_at", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error) {
    console.error(
      `[EarningsSignalSvc] Error checking staleness for ${symbol}: ${error.message}. Assuming stale.`
    );
    return true;
  }

  if (!latestSignal?.created_at) {
    return true; // No existing signals of this type for this symbol
  }

  const lastGeneratedTime = new Date(latestSignal.created_at).getTime();
  const isStale = Date.now() - lastGeneratedTime >= EARNINGS_SIGNALS_TTL_MS;
  if (!isStale) {
    console.log(
      `[EarningsSignalSvc] Signals for ${symbol} are fresh. Last generation: ${latestSignal.created_at}.`
    );
  }
  return isStale;
}

// --- Exported Service Function ---
export async function processEarningsSignalsForSymbol(
  symbol: string,
  supabaseInstance?: SupabaseClient
): Promise<EarningsProcessingResult> {
  const supabase = supabaseInstance || getSupabaseServerClient();
  const upperSymbol = symbol.toUpperCase();
  const today = new Date();
  const todayStr = today.toISOString().split("T")[0]; // YYYY-MM-DD format

  console.log(
    `[EarningsSignalSvc] Processing earnings signals for symbol: ${upperSymbol}`
  );

  if (!(await areSignalsStale(supabase, upperSymbol))) {
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "skipped_fresh",
    };
  }

  console.log(
    `[EarningsSignalSvc] Signals for ${upperSymbol} are stale or missing. Generating...`
  );
  const { signals, error: generationError } = await generateSignalsLogic(
    supabase,
    upperSymbol,
    today, // Pass Date object
    todayStr
  );

  if (generationError) {
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "error",
      error: generationError,
    };
  }

  if (!signals || signals.length === 0) {
    console.log(
      `[EarningsSignalSvc] No new earnings signals generated for ${upperSymbol} (no relevant calendar data or conditions met).`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "no_data_for_generation",
    };
  }

  const typedSignalsToInsert =
    signals as Database["public"]["Tables"]["signals"]["Insert"][];
  const { error: upsertError } = await supabase
    .from(SIGNALS_TABLE_NAME)
    .upsert(typedSignalsToInsert, {
      onConflict: "symbol, signal_date, signal_code", // Relies on signal_date being todayStr for upsert logic
    });

  if (upsertError) {
    console.error(
      `[EarningsSignalSvc] Error upserting signals for ${upperSymbol}: ${upsertError.message}`
    );
    return {
      processedSymbol: upperSymbol,
      signalsGenerated: 0,
      status: "error",
      error: `Failed to upsert signals: ${upsertError.message}`,
    };
  }

  console.log(
    `[EarningsSignalSvc] Successfully generated and upserted ${signals.length} signals for ${upperSymbol}.`
  );
  return {
    processedSymbol: upperSymbol,
    signalsGenerated: signals.length,
    status: "processed",
  };
}
